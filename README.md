# learn-java-class-load
> 学习java的类加载机制

## 定义
- Java虚拟机把类编译后class文件经过加载、验证、准备、解析和初始化后，形成可被程序直接使用的运行时类结构的全过程

## 过程
- 加载: 通过“全限定名”找到 .class 字节流，读进来后在方法区生成一个与该类对应的数据结构，同时在堆中实例化一个 java.lang.Class 对象作为访问入口
- 验证: 确保字节码符合 JVM 格式、语义安全，不会危害虚拟机
- 准备: 为类变量（static 字段）分配内存并设置默认值
- 解析: 将常量池中的符号引用替换为直接引用
- 初始化: 执行 <clinit> 方法，真正给 static 字段赋程序指定的初始值，执行 static 代码块
> 注意: 主类在运行过程中如果使用到其他类才会逐步加载这些类。jar包或war包中的类不是一次性全部加载，是使用到才加载。

## 类加载器
> 上面的类加载过程是通过类加载器来实现的
- 引导类加载器: 加载jre的lib目录下核心类
- 扩展类加载器: 加载jre的lib目录下ext目录的jar文件中的类
- 应用程序类加载器: 加载自己写的类
- 自定义类加载器: 加载用户自定义路径下的类
> 注意: "自定义类加载器"的父类加载器是"应用程序类加载器"; "应用程序类加载器"的父类加载器是"扩展类加载器"; "扩展类加载器"没有父类加载器

### 类加载器初始化过程
- JVM启动时实例sun.misc.Launcher。sun.misc.Launcher初始化使用了单例模式，保证一个虚拟机内只有一个实例
- 在sun.misc.Launcher构造方法内部创建了sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应用类加载器)
- JVM默认使用应用类加载器来加载我们自己写的类

## 双亲委派机制
- JVM 类加载器在接到加载请求时，必须先将请求向上委托给父加载器，只有父加载器无法完成时，才由自身尝试加载的层级委托模型。
- 首先,检查一下指定名称的类是否已经加载过,如果加载过了,就不需要再加载,直接返回。
- 如果此类没有加载过,那么,再判断一下是否有父加载器;如果有父加载器,则由父加载器加载或者是调用引导类加载器来加载。
- 如果父加载器及引导类加载器都没有找到指定的类,那么调用当前类加载器来完成类加载。
- [双亲委派模型图](./双亲委派模型.eddx)

## 自定义类加载器

### 实现方式
- 参考org.muyi.ljcl.classloader.MyClassLoader
### 测试
- 准备被自定义类加载器加载的类(LoadedClass)
- 编译被自定义加载器加载的类，获取到编译后的class文件
- 将class文件放在非classPath路径下(~/org/muyi/ljcl/classloader/)
- 将原来的LoadedClass换个类名（运行时会在classpath路径下产生一个与要使用自定义类加载器加载的类同名的class文件，现在还没打破双亲委派模型，会使用应用类加载器加载类，而不会使用自定义的类加载器来加载）